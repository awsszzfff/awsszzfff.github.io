---
title: 灵神题单-基础算法精讲刷题记录
date: 2025-12-28
updated: 2025-12-28
tags:
  - 刷题记录
categories:
  - 程序设计
description: 灵神题单-基础算法精讲刷题记录
---
[【基础算法精讲·题目汇总】](https://github.com/EndlessCheng/codeforces-go/blob/master/leetcode/README.md) [【基础算法精讲】](https://space.bilibili.com/206214/channel/collectiondetail?sid=842776) 

## 相向双指针 1

### [167. 两数之和 II - 输入有序数组](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/)

利用数组有序这一特点，左右两个指针相加和 target 相比，则每次遍历所获得的信息量为 n；暴力做法每次遍历所获得的信息量为 1。

用 `O(1)` 的时间获得 `O(n)` 的信息

```python
class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        left = 0
        right = len(numbers) - 1
        while left < right:
            if numbers[left] + numbers[right] > target:
                right -= 1
            elif numbers[left] + numbers[right] < target:
                left += 1
            else:
                return [left + 1, right + 1]
        return []
```

### [15. 三数之和](https://leetcode.cn/problems/3sum/) @

排序，枚举 i，即将问题转换为另外两个数之和的问题；

*不可包含重复的三元组*，先分析什么时候会出现重复的三元组（eg：`[-4, -1, -1, 0, 1, 2]`，前面两个 -1 和后面的数组合会重复）遇见重复跳过即可。

```python
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        nums.sort()
        ans = []
        n = len(nums)
        for i in range(n - 2):
            if i > 0 and nums[i] == nums[i - 1]:
                continue
                
            # 两种优化
            if nums[i] + nums[i + 1] + nums[i + 2] > 0:
                break
            if nums[i] + nums[-1] + nums[-2] < 0:
                continue
            
            j = i + 1
            k = n - 1
            while j < k:
                s = nums[i] + nums[j] + nums[k]
                if s > 0:
                    k -= 1
                elif s < 0:
                    j += 1
                else:
                    # ans.append([nums[i], nums[j], nums[k]])
                    # j += 1
                    # while j < k and nums[j] == nums[j - 1]:
                    #     j += 1
                    # k -= 1
                    # while j < k and nums[k] == nums[k + 1]:
                    #     k -= 1

                    # j == i + 1 表示刚开始双指针，j 左边没有数字
                    # nums[j] != nums[j - 1] 说明与上一轮的三元组不同
                    if j == i + 1 or nums[j] != nums[j - 1]:
                        ans.append([nums[i], nums[j], nums[k]])
                    j += 1
                    k -= 1
        return ans
```

### [2824. 统计和小于目标的下标对数目](https://leetcode.cn/problems/count-pairs-whose-sum-is-less-than-target/)



### [16. 最接近的三数之和](https://leetcode.cn/problems/3sum-closest/)



### [18. 四数之和](https://leetcode.cn/problems/4sum/)



### [611. 有效三角形的个数](https://leetcode.cn/problems/valid-triangle-number/)

## 相向双指针 2

### [11. 盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/) @

分析题目：高度取当前两条线最小的，宽度取两条线之间的距离。

分类讨论：当前已有的长方形面积，固定当前高的那条线，另一条短线移动

- 若是中间更短的线/一样长的线，即高度/宽度减小，不可能比原来面积大；
- 若是中间有更长的线，则高增大，宽减小，需判断和原面积的大小；

即**若要找到面积更大的，则不可能是和当前的短线组成的**。

```python
class Solution:
    def maxArea(self, height: List[int]) -> int:
        left = 0
        right = len(height) - 1
        ans = 0
        while left < right:
            area = min(height[left], height[right]) * (right - left)
            ans = max(ans, area)
            if height[left] > height[right]:	# 固定当前高的那条线
                right -= 1
            else:
                left += 1
        return ans
```

### [42. 接雨水](https://leetcode.cn/problems/trapping-rain-water/) @

#### 前后缀分解/动态规划

计算每个单位的水桶可以接多少水，单位水桶左边的高度取决于左边的最大高度，右边取决于右边的最大高度；

则计算前缀最大值数组、后缀最大值数组，即保证当前单位水桶中的水是不会流出去的。

> 对于当前列，只需关注左边最高墙和右边最高墙中较矮的一个即可，三种情况：
> - 较矮墙高度大于当前列，则当前列的水量为 `矮墙高度-当前列高度`；
> - 较矮墙高度小于当前列，则当前列无水；
> - 较矮墙高度等于当前列，则当前列无水。
> 
> 最两端不用考虑，因为一定不会有水。
> 
> [windliang 思路分析及多解](https://leetcode.cn/problems/trapping-rain-water/solutions/9112/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-w-8/)

```python
class Solution:
    def trap(self, height: List[int]) -> int:
    	# 时间复杂度 O(n)
    	# 空间复杂度 O(n)
        n = len(height)
        
        # 第i列左侧最高墙
        pre_max = [0] * n
        pre_max[0] = height[0]
        for i in range(1, n):
            pre_max[i] = max(pre_max[i - 1], height[i])
            
        # 第i列右侧最高墙
        suf_max = [0] * n
        suf_max[n - 1] = height[n - 1]
        for i in range(n - 2, -1, -1):
            suf_max[i] = max(suf_max[i + 1], height[i])
            
        ans = 0
        for pre, suf, h in zip(pre_max, suf_max, height):
            ans += min(pre, suf) - h
            
        return ans
```

#### 相向双指针

若左侧最大值比右侧最大值小，则当前木桶接水的容量即为左侧最大值，随后向右扩展；反之，同理。

```python
class Solution:
    def trap(self, height: List[int]) -> int:
        # 时间复杂度 O(n)
        # 空间复杂度 O(1)
        n = len(height)
        ans = 0

        left = 0
        right = n - 1

        pre_max = 0
        suf_max = 0

        while left < right:
            pre_max = max(pre_max, height[left])
            suf_max = max(suf_max, height[right])
            if pre_max < suf_max:
                ans += pre_max - height[left]
                left += 1
            else:
                ans += suf_max - height[right]
                right -= 1
                
        return ans
```

#### 单调栈

```python

```

### [125. 验证回文串](https://leetcode.cn/problems/valid-palindrome/)



### [2105. 给植物浇水 II](https://leetcode.cn/problems/watering-plants-ii/)

## 滑动窗口

同向双指针

### [209. 长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/)

利用数组相加后得到的 s 的值的单调性，双指针实现。

```python
class Solution:
    def minSubArrayLen(self, target: int, nums: List[int]) -> int:
    	# 时间复杂度O(n)
    	# 空间复杂度O(1)
        n = len(nums)
        ans = float('inf')
        left = 0
        s = 0
        for right, x in enumerate(nums):  # 枚举右端点
            s += x
            # 由于均未正数，向右移动添加的值的总和只会更大，长度只会>=最小目标值长度
            while s >= target:
                ans = min(ans, right - left + 1)
                s -= nums[left]
                left += 1  # 满足条件，左端点右移
        return ans if ans != float('inf') else 0
```

> 虽然写了个二重循环，但是内层循环中对 left 加一的总执行次数不会超过 n 次，所以总的时间复杂度为 O(n)。

### [3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)

```python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        # 时间复杂度 O(n)
        # 空间复杂度 O(128) O(1) O(len(set(s)))

        # # 用字符串
        # sub = ""
        # ans = 0
        # left = 0
        # for right, c in enumerate(s):
        #     sub += c
        #     while sub.count(c) > 1:
        #         sub = sub[1:]
        #         left += 1
        #     ans = max(ans, right - left + 1)
        # return ans

        # # 用哈希表
        # ans = 0
        # left = 0
        # cnt = defaultdict(int)
        # for right, c in enumerate(s):
        #     cnt[c] += 1
        #     while cnt[c] > 1:
        #         cnt[s[left]] -= 1
        #         left += 1
        #     ans = max(ans, right - left + 1)
        # return ans

        # 哈希集合
        ans = 0
        left = 0
        window = set()
        for right, c in enumerate(s):
            while c in window:
                window.remove(s[left])
                left += 1
            window.add(c)
            ans = max(ans, right - left + 1)
        return ans
```

### [713. 乘积小于 K 的子数组](https://leetcode.cn/problems/subarray-product-less-than-k/)

若 left 到 right 之间的数总乘积都小于 k，则它们之间的任何数乘积都小于 k。

```python
class Solution:
    def numSubarrayProductLessThanK(self, nums: List[int], k: int) -> int:
        # 时间复杂度O(n)
        # 空间复杂度O(1)
        if k <= 1:
            return 0
        ans = 0
        left = 0
        s = 1
        for right, x in enumerate(nums):
            s *= x
            while s >= k:
                s /= nums[left]
                left += 1
            # 若 left 到 right 之间的数总乘积都小于 k，则它们之间的任何数乘积都小于 k。
            ans += right - left + 1
        return ans
```

### [3090. 每个字符最多出现两次的最长子字符串](https://leetcode.cn/problems/maximum-length-substring-with-two-occurrences/)

### [2958. 最多 K 个重复元素的最长子数组](https://leetcode.cn/problems/length-of-longest-subarray-with-at-most-k-frequency/)

### [2730. 找到最长的半重复子字符串](https://leetcode.cn/problems/find-the-longest-semi-repetitive-substring/)

### [2779. 数组的最大美丽值](https://leetcode.cn/problems/maximum-beauty-of-an-array-after-applying-operation/)

### [1004. 最大连续 1 的个数 III](https://leetcode.cn/problems/max-consecutive-ones-iii/)

### [2962. 统计最大元素出现至少 K 次的子数组](https://leetcode.cn/problems/count-subarrays-where-max-element-appears-at-least-k-times/)

### [2302. 统计得分小于 K 的子数组数目](https://leetcode.cn/problems/count-subarrays-with-score-less-than-k/)

### [1658. 将 x 减到 0 的最小操作数](https://leetcode.cn/problems/minimum-operations-to-reduce-x-to-zero/)

### [1234. 替换子串得到平衡字符串](https://leetcode.cn/problems/replace-the-substring-for-balanced-string/)

### [76. 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/) @


## 二分查找

> 区间内的数（下标）都是还未确定与 target 的大小关系的，有的是 < target，有的是 ≥ target；区间外的数（下标）都是确定与 target 的大小关系的。

### [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/) @

```python
class Solution:
    def lower_bound1(self, nums, target):
        left = 0
        right = len(nums) - 1
        # 闭区间 [left, right]
        while left <= right:  # 区间不为空
            mid = left + (right - left) // 2
            if nums[mid] < target:
                left = mid + 1
            else:
                right = mid - 1
        # 循环结束后 left = right+1
        # 此时 nums[left-1] < target 而 nums[left] = nums[right+1] >= target
        # 所以 left 就是第一个 >= target 的元素下标
        return left

    def lower_bound2(self, nums, target):
        left = 0
        right = len(nums)
        # 左闭右开 [left, right)
        while left < right:  # 区间不为空
            mid = left + (right - left) // 2
            if nums[mid] < target:
                left = mid + 1
            else:
                right = mid
        # 循环结束后 left = right
        # 此时 nums[left-1] < target 而 nums[left] = nums[right] >= target
        # 所以 left 就是第一个 >= target 的元素下标
        return left

    def lower_bound3(self, nums, target):
        left = -1
        right = len(nums)
        # 开区间[left, right]
        while left + 1 < right: # 区间不为空
            mid = left + (right - left) // 2
            if nums[mid] < target:
                left = mid
            else:
                right = mid
        # 循环结束后 left+1 = right
        # 此时 nums[left] < target 而 nums[right] >= target
        # 所以 right 就是第一个 >= target 的元素下标
        return right

    def searchRange(self, nums: List[int], target: int) -> List[int]:
        start = self.lower_bound3(nums, target)
        if start == len(nums) or nums[start] != target:
            return [-1, -1]
        end = self.lower_bound3(nums, target + 1) - 1
        return [start, end]
```

库函数写法

```python
def searchRange(self, nums: List[int], target: int) -> List[int]:
    start = bisect_left(nums, target)
    if start == len(nums) or nums[start] != target:
        return [-1, -1]
    end = bisect_right(nums, target) - 1
    return [start, end]
```

### [2529. 正整数和负整数的最大计数](https://leetcode.cn/problems/maximum-count-of-positive-integer-and-negative-integer/)

### [2300. 咒语和药水的成功对数](https://leetcode.cn/problems/successful-pairs-of-spells-and-potions/)


### [1385. 两个数组间的距离值](https://leetcode.cn/problems/find-the-distance-value-between-two-arrays/)

### [2080. 区间内查询数字的频率](https://leetcode.cn/problems/range-frequency-queries/)

### [2563. 统计公平数对的数目](https://leetcode.cn/problems/count-the-number-of-fair-pairs/)

### [875. 爱吃香蕉的珂珂](https://leetcode.cn/problems/koko-eating-bananas/)

### [2187. 完成旅途的最少时间](https://leetcode.cn/problems/minimum-time-to-complete-trips/)

### [275. H 指数 II](https://leetcode.cn/problems/h-index-ii/)

### [2861. 最大合金数](https://leetcode.cn/problems/maximum-number-of-alloys/)

### [2439. 最小化数组中的最大值](https://leetcode.cn/problems/minimize-maximum-of-array/)

### [2517. 礼盒的最大甜蜜度](https://leetcode.cn/problems/maximum-tastiness-of-candy-basket/)

## 二分查找 - 变形

分析题目，确定当前题目中的 **target** 所在的二分区间。

### [162. 寻找峰值](https://leetcode.cn/problems/find-peak-element/)

`nums[-1] = nums[n] = -∞` 即一定存在峰值，判断 `nums[i]` 和 `nums[i+1]` 大小，若 `>` 说明左边一定存在峰值；若 `<` 说明右边一定存在峰值。

```python
class Solution:
    def findPeakElement(self, nums: List[int]) -> int:
        left = 0
        right = len(nums) - 1
        while left < right:
            mid = left + (right - left) // 2
            if nums[mid] > nums[mid + 1]:
                right = mid
            else:
                left = mid + 1
        return left
```

### [153. 寻找旋转排序数组中的最小值](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/) @

> `x=nums[mid]` 判断 x 和数组最小值的位置关系，谁在左边，谁在右边？
> 
> 把 x 与最后一个数 `nums[n−1]` 比大小
> 
> - 如果 `x>nums[n−1]`，那么可以推出以下结论：
> 	- nums 一定被分成左右两个递增段；
> 	- 第一段的所有元素均大于第二段的所有元素；
> 	- x 在第一段。
> 	- 最小值在第二段。
> 	- 所以 x 一定在最小值的左边。
> - 如果 `x <= nums[n−1]`，那么 x 一定在第二段。（或者 nums 就是递增数组，此时只有一段。）
> 	- x 要么是最小值，要么在最小值右边。

> 对于二分来说，代码中的 `if (nums[mid] > nums[-1])` 在 `mid = n − 1` 的时候一定不成立。所以对于左闭右开的写法，right 可以选择从 `n - 1` 处开始

```python
class Solution:
    def findMin(self, nums: List[int]) -> int:
        left = 0
        right = len(nums) - 1
        while left < right:
            mid = left + (right - left) // 2
            if nums[mid] > nums[-1]:
                left = mid + 1
            else:
                right = mid
        return nums[left]
```

### [33. 搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/) @

#### 两次二分

先找最小值，再在有序数组中找 target

```python
class Solution:
    def findMin(self, nums):
        left = 0
        right = len(nums)
        while left < right:
            mid = left + (right - left) // 2
            if nums[mid] > nums[-1]:
                left = mid + 1
            else:
                right = mid
        return left

    def lower_bound(self, nums, left, right, target):
        while left < right:
            mid = left + (right - left) // 2
            if nums[mid] < target:
                left = mid + 1
            else:
                right = mid
        return left if nums[left] == target else -1

    def search(self, nums: List[int], target: int) -> int:
        i = self.findMin(nums)
        if target > nums[-1]:
            return self.lower_bound(nums, 0, i, target)
        return self.lower_bound(nums, i, len(nums), target)
```

#### 一次二分

> - 如果 x 和 target 在不同的递增段：
> 	- 如果 target 在第一段，x 在第二段，说明 target 在 x 在左边。
> 	- 如果 x 在第一段，target 在第二段，说明 target 在 x 在右边。
> - 如果 x 和 target 在相同的递增段：
> 	- 和 lowerBound 函数一样，比较 x 和 target 的大小即可。

```python
# 写法一
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        left = 0
        right = len(nums)
        while left < right:
            mid = left + (right - left) // 2
            x = nums[mid]
            if target > nums[-1] >= x:
                right = mid
            elif x > nums[-1] >= target:
                left = mid + 1
            elif x >= target:
                right = mid
            else:
                left = mid + 1
        return left if nums[left] == target else -1
```

> 只讨论 target 在 x 左边，或者 x=target 的情况。其余情况 target 一定在 x 的右边
> 
> - 如果 `x > nums[n−1]`，说明 x 在第一段中，那么 target 也必须在第一段中（否则 target 一定在 x 的右边）且 x 必须大于等于 target。
> 	- 写成代码就是 `target > nums[n - 1] && x >= target`。
> - 如果 `x <= nums[n−1]`，说明 x 在第二段中（或者 nums 只有一段），那么 target 可以在第一段，也可以在第二段。
> 	- 如果 target 在第一段，那么 target 一定在 x 左边。
> 	- 如果 target 在第二段，那么 x 必须大于等于 target。
> 	- 写成代码就是 `target > nums[n - 1] || x >= target`。

```python
# 写法二
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        def check(i):
            x = nums[i]
            if x > nums[-1]:
                return target > nums[-1] and x >= target
            return target > nums[-1] or x >= target

        left, right = 0, len(nums)
        while left < right:
            mid = left + (right - left) // 2
            if check(mid):
                right = mid
            else:
                left = mid + 1
        return left if nums[left] == target else -1
```

### [74. 搜索二维矩阵](https://leetcode.cn/problems/search-a-2d-matrix/) @

### [1901. 寻找峰值 II](https://leetcode.cn/problems/find-a-peak-element-ii/)

### [154. 寻找旋转排序数组中的最小值 II](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii/)

## 链表 - 反转系列

### [206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/) @

```python
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        cur = head
        pre = None
        while cur:
            nxt = cur.next
            cur.next = pre
            pre = cur
            cur = nxt
        return pre
```

### [92. 反转链表 II](https://leetcode.cn/problems/reverse-linked-list-ii/)

![[attachments/20260106.png]]

```python
class Solution:
    def reverseBetween(self, head: Optional[ListNode], left: int, right: int) -> Optional[ListNode]:
        dummy = ListNode(next=head)
        p0 = dummy
        for _ in range(left - 1):
            p0 = p0.next

        pre = None
        cur = p0.next
        for _ in range(right - left + 1):
            nxt = cur.next
            cur.next = pre
            pre = cur
            cur = nxt
        p0.next.next = cur
        p0.next = pre
        return dummy.next
```

### [25. K 个一组翻转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group/) @

![[../Hot100/attachments/20260106-1.png]]

```python
class Solution:
    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:
        dummy = ListNode(next=head)

        cur = head
        count = 0
        while cur:
            count += 1
            cur = cur.next
        n = count // k

        p0 = dummy
        pre = None
        cur = p0.next
        for _ in range(n):
            for _ in range(k):
                nxt = cur.next
                cur.next = pre
                pre = cur
                cur = nxt
            nxt = p0.next
            p0.next.next = cur
            p0.next = pre
            p0 = nxt

        return dummy.next
```

### [24. 两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/) @


### [445. 两数相加 II](https://leetcode.cn/problems/add-two-numbers-ii/)


### [2816. 翻倍以链表形式表示的数字](https://leetcode.cn/problems/double-a-number-represented-as-a-linked-list/)

## 链表 - 快慢指针

### [876. 链表的中间结点](https://leetcode.cn/problems/middle-of-the-linked-list/)

数学归纳，分别讨论节点为奇数和偶数的情况

```python
class Solution:
    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:
        fast = head
        slow = head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
        return slow
```

### [141. 环形链表](https://leetcode.cn/problems/linked-list-cycle/) @

```python
class Solution:
    def hasCycle(self, head: Optional[ListNode]) -> bool:
        slow = head
        fast = head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
            if fast is slow:
                return True
        return False
```

### [142. 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/) @

数学的方式分析快慢指针相遇和到达环入口的各种情况

> 设 head 到环入口 a，环长 b，总长 `a+b`
> 
> - fast 走的步数是 slow 步数的 2 倍，即 `f=2s`；（解析： fast 每轮走 2 步）
> - fast 比 slow 多走了 n 个环的长度，即 `f=s+nb`；（ 解析： 双指针都走过 a 步，然后在环内绕圈直到重合，重合时 fast 比 slow 多走环的长度整数倍 ）。
> 
> 则有 `s=nb`
> 
> 指针一直向前走计为 k，则走到环入口处有 `k=a+bn`。则相遇时 slow 走了 `nb` 步，再走 a 步就可以到达入口，a 未知，同时当 head 走 a 步也会到达入口。

![[attachments/20260107.png]]

> 相遇一定在环内，设 fast 比 slow 快一步到环，则相遇时 fast 一定得走 `环长-1`，slow 走的步数一定小于环长。

```python
class Solution:
    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:
        slow = head
        fast = head
        while fast and fast.next:
            fast = fast.next.next
            slow = slow.next
            if fast is slow:
                while slow is not head:
                    slow = slow.next
                    head = head.next
                return slow
        return None
```

### [143. 重排链表](https://leetcode.cn/problems/reorder-list/)

利用寻找中间节点和翻转链表，随后将两个链表进行合并

```python
class Solution:
    def middleNode(self, head):
        slow = head
        fast = head
        while fast and fast.next:
            fast = fast.next.next
            slow = slow.next
        return slow

    def reverseList(self, head):
        pre = None
        cur = head
        while cur:
            nxt = cur.next
            cur.next = pre
            pre = cur
            cur = nxt
        return pre

    def reorderList(self, head: Optional[ListNode]) -> None:
        """
        Do not return anything, modify head in-place instead.
        """
        mid = self.middleNode(head)
        head2 = self.reverseList(mid)
        while head2.next:
            nxt = head.next
            nxt2 = head2.next
            head.next = head2
            head2.next = nxt
            head = nxt
            head2 = nxt2
```

### [234. 回文链表](https://leetcode.cn/problems/palindrome-linked-list/) @

### [2130. 链表最大孪生和](https://leetcode.cn/problems/maximum-twin-sum-of-a-linked-list/) -

## 链表 - 删除系列

### [237. 删除链表中的节点](https://leetcode.cn/problems/delete-node-in-a-linked-list/)

```python
class Solution:
    def deleteNode(self, node):
        """
        :type node: ListNode
        :rtype: void Do not return anything, modify node in-place instead.
        """

        node.val = node.next.val
        node.next = node.next.next
```

### [19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/) @

```python
class Solution:
    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:
        left = right = dummy_head = ListNode(0, head)
        for _ in range(n):
            right = right.next
        while right.next:
            right = right.next
            left = left.next
        left.next = left.next.next
        return dummy_head.next
```

### [83. 删除排序链表中的重复元素](https://leetcode.cn/problems/remove-duplicates-from-sorted-list/)

```python
class Solution:
    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if head is None:
            return head
        cur = head
        while cur.next:
            if cur.val == cur.next.val:
                cur.next = cur.next.next
            else:
                cur = cur.next
        return head
```

### [82. 删除排序链表中的重复元素 II](https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/)

```python
class Solution:
    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:
        cur = dummy_head = ListNode(0, head)
        while cur.next and cur.next.next:
            val = cur.next.val
            if cur.next.next.val == val:
                while cur.next and cur.next.val == val:
                    cur.next = cur.next.next
            else:
                cur = cur.next
        return dummy_head.next
```

### [203. 移除链表元素](https://leetcode.cn/problems/remove-linked-list-elements/)

### [3217. 从链表中移除在数组中存在的节点](https://leetcode.cn/problems/delete-nodes-from-linked-list-present-in-array/)

### [2487. 从链表中移除节点](https://leetcode.cn/problems/remove-nodes-from-linked-list/)

## 二叉树与递归 - 深入理解

### [104. 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/) @

从原问题出发，将原问题分解为更小（相同）的子问题。确定边界条件！

![[attachments/20260109.png]]

```python
class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        # 把节点传下去
        if root is None:
            return 0
        ldepth = self.maxDepth(root.left)
        rdepth = self.maxDepth(root.right)
        return max(ldepth, rdepth) + 1
```

```python
class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        # 把路径上的节点个数传下去
        ans = 0

        def dfs(root, depth):
            if root is None:
                return
                
            depth += 1
            nonlocal ans
            ans = max(ans, depth)
            
            dfs(root.left, depth)
            dfs(root.right, depth)

        dfs(root, 0)

        return ans
```

### [111. 二叉树的最小深度](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)

### [404. 左叶子之和](https://leetcode.cn/problems/sum-of-left-leaves/)

### [112. 路径总和](https://leetcode.cn/problems/path-sum/)

### [129. 求根节点到叶节点数字之和](https://leetcode.cn/problems/sum-root-to-leaf-numbers/)


### [1448. 统计二叉树中好节点的数目](https://leetcode.cn/problems/count-good-nodes-in-binary-tree/)

### [987. 二叉树的垂序遍历](https://leetcode.cn/problems/vertical-order-traversal-of-a-binary-tree/)

## 二叉树与递归 - 灵活运用

### [100. 相同的树](https://leetcode.cn/problems/same-tree/)

```python
class Solution:
    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:
        if p is None or q is None:
            return p is q
        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)
```

### [101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/) @

```python
class Solution:
    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]):
        if p is None or q is None:
            return p is q
        return p.val == q.val and self.isSameTree(p.left, q.right) and self.isSameTree(p.right, q.left)

    def isSymmetric(self, root: Optional[TreeNode]) -> bool:
        return self.isSameTree(root.left, root.right)
```

### [110. 平衡二叉树](https://leetcode.cn/problems/balanced-binary-tree/)

用 -1 来表示不平衡，若有返回 -1 则提前退出。

```python
class Solution:
    def isBalanced(self, root: Optional[TreeNode]) -> bool:
        def get_height(node):
            if node is None:
                return 0
                
            depth_left = get_height(node.left)
            if depth_left == -1:	# 提前退出，不再递归
            	return -1
            	
            depth_right = get_height(node.right)
            if depth_right == -1 or abs(depth_left - depth_right) > 1:
                return -1
                
            return max(depth_left, depth_right) + 1

        return get_height(root) != -1
```

### [199. 二叉树的右视图](https://leetcode.cn/problems/binary-tree-right-side-view/) @

> 先遍历右子树，两个问题：
> 
> - 怎么把答案记下来：全局的数组来记录。
> - 如何判断当前节点是否需要记录到答案中：递归时记录每个节点的深度，若深度等于当前记录节点的个数，则说明当前节点为该层的第一个，存入数组中。

```python
class Solution:
    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:
        ans = []

        def dfs(node, depth):
            if node is None:
                return
            if depth == len(ans):
                ans.append(node.val)
            dfs(node.right, depth + 1)
            dfs(node.left, depth + 1)

        dfs(root, 0)

        return ans
```

### [226. 翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/) @

```python
class Solution:
    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        if root is None:
            return None
        self.invertTree(root.left)
        self.invertTree(root.right)
        root.left, root.right = root.right, root.left
        return root
# 另一种方式是先交换左右儿子再递归翻转对应的左右子树
```

### [617. 合并二叉树](https://leetcode.cn/problems/merge-two-binary-trees/)

### [1026. 节点与其祖先之间的最大差值](https://leetcode.cn/problems/maximum-difference-between-node-and-ancestor/)

### [1080. 根到叶路径上的不足节点](https://leetcode.cn/problems/insufficient-nodes-in-root-to-leaf-paths/)

## 二叉树与递归 - 前序/中序/后序

### [98. 验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/) @

#### 前序遍历

![[attachments/20260110.png]]

范围从上往下传导，左子树的值 `(-∞, root.val)` 右子树的值 `(root.val, +∞)` 。

```python
class Solution:
    def isValidBST(self, root: Optional[TreeNode], left=-inf, right=inf) -> bool:
        if root is None:
            return True
        x = root.val
        return left < x < right and self.isValidBST(root.left, left, x) and self.isValidBST(root.right, x, right)
```

#### 中序遍历

判断整个序列是否是一个严格递增的数组

```python
class Solution:
    pre = -inf

    def isValidBST(self, root: Optional[TreeNode]) -> bool:
        if root is None:
            return True
        if not self.isValidBST(root.left):
            return False
        if self.pre >= root.val:
            return False
        self.pre = root.val
        return self.isValidBST(root.right)
```

#### 后序遍历

![[attachments/20260110-1.png]]

从下向上传导左右子树的最大值和最小值

```python
class Solution:
    def isValidBST(self, root: Optional[TreeNode]) -> bool:
        def dfs(node):
            if node is None:
                return inf, -inf
            l_min, l_max = dfs(node.left)
            r_min, r_max = dfs(node.right)
            x = node.val
            if x <= l_max or x >= r_min:
                return -inf, inf
            return min(x, l_min), max(x, r_max)

        return dfs(root)[1] != inf
```

### [938. 二叉搜索树的范围和](https://leetcode.cn/problems/range-sum-of-bst/)

### [2476. 二叉搜索树最近节点查询](https://leetcode.cn/problems/closest-nodes-queries-in-a-binary-search-tree/)

### [230. 二叉搜索树中第 K 小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-bst/)

### [1373. 二叉搜索子树的最大键值和](https://leetcode.cn/problems/maximum-sum-bst-in-binary-tree/)

### [105. 从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/) @

```python

```

### [106. 从中序与后序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

### [889. 根据前序和后序遍历构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-postorder-traversal/)

### [1110. 删点成林](https://leetcode.cn/problems/delete-nodes-and-return-forest/)

## 二叉树与递归 - 最近公共祖先

### [236. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/) @

![[attachments/20260111.png]]

```python
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        if root is None or root is p or root is q:
            return root
        left = self.lowestCommonAncestor(root.left, p, q)
        right = self.lowestCommonAncestor(root.right, p, q)
        if left and right:
            return root
        if left:
            return left
        return right
```

### [235. 二叉搜索树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/)

![[attachments/20260111-1.png]]

```python
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        x = root.val
        if p.val < x and q.val < x:
            return self.lowestCommonAncestor(root.left, p, q)
        elif p.val > x and q.val > x:
            return self.lowestCommonAncestor(root.right, p, q)
        else:
            return root
```

### [1123. 最深叶节点的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-deepest-leaves/)

## 二叉树 - BFS

### [102. 二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/) @

### [103. 二叉树的锯齿形层序遍历](https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/)

### [513. 找树左下角的值](https://leetcode.cn/problems/find-bottom-left-tree-value/)

### [107. 二叉树的层序遍历 II](https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/)

### [116. 填充每个节点的下一个右侧节点指针](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/)

### [117. 填充每个节点的下一个右侧节点指针 II](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/)

### [2415. 反转二叉树的奇数层](https://leetcode.cn/problems/reverse-odd-levels-of-binary-tree/)

### [2641. 二叉树的堂兄弟节点 II](https://leetcode.cn/problems/cousins-in-binary-tree-ii/)

## 回溯 - 子集型

### [17. 电话号码的字母组合](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/) @

### [78. 子集](https://leetcode.cn/problems/subsets/) @

### [131. 分割回文串](https://leetcode.cn/problems/palindrome-partitioning/) @

### [2698. 求一个整数的惩罚数](https://leetcode.cn/problems/find-the-punishment-number-of-an-integer/)

