---
title: 灵神题单-基础算法精讲刷题记录
date: 2025-12-28
updated: 2025-12-28
tags:
  - 刷题记录
categories:
  - 程序设计
description: 灵神题单-基础算法精讲刷题记录
---
[【基础算法精讲·题目汇总】](https://github.com/EndlessCheng/codeforces-go/blob/master/leetcode/README.md) [【基础算法精讲】](https://space.bilibili.com/206214/channel/collectiondetail?sid=842776) 

## 相向双指针 1

### [167. 两数之和 II - 输入有序数组](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/)

利用数组有序这一特点，左右两个指针相加和 target 相比，则每次遍历所获得的信息量为 n；暴力做法每次遍历所获得的信息量为 1。

用 `O(1)` 的时间获得 `O(n)` 的信息

```python
class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        left = 0
        right = len(numbers) - 1
        while left < right:
            if numbers[left] + numbers[right] > target:
                right -= 1
            elif numbers[left] + numbers[right] < target:
                left += 1
            else:
                return [left + 1, right + 1]
        return []
```

### [15. 三数之和](https://leetcode.cn/problems/3sum/)

排序，枚举 i，即将问题转换为另外两个数之和的问题；

*不可包含重复的三元组*，先分析什么时候会出现重复的三元组（eg：`[-4, -1, -1, 0, 1, 2]`，前面两个 -1 和后面的数组合会重复）遇见重复跳过即可。

```python
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        nums.sort()
        ans = []
        n = len(nums)
        for i in range(n - 2):
            if i > 0 and nums[i] == nums[i - 1]:
                continue
                
            # 两种优化
            if nums[i] + nums[i + 1] + nums[i + 2] > 0:
                break
            if nums[i] + nums[-1] + nums[-2] < 0:
                continue
            
            j = i + 1
            k = n - 1
            while j < k:
                s = nums[i] + nums[j] + nums[k]
                if s > 0:
                    k -= 1
                elif s < 0:
                    j += 1
                else:
                    # ans.append([nums[i], nums[j], nums[k]])
                    # j += 1
                    # while j < k and nums[j] == nums[j - 1]:
                    #     j += 1
                    # k -= 1
                    # while j < k and nums[k] == nums[k + 1]:
                    #     k -= 1

                    # j == i + 1 表示刚开始双指针，j 左边没有数字
                    # nums[j] != nums[j - 1] 说明与上一轮的三元组不同
                    if j == i + 1 or nums[j] != nums[j - 1]:
                        ans.append([nums[i], nums[j], nums[k]])
                    j += 1
                    k -= 1
        return ans
```

### [2824. 统计和小于目标的下标对数目](https://leetcode.cn/problems/count-pairs-whose-sum-is-less-than-target/)



### [16. 最接近的三数之和](https://leetcode.cn/problems/3sum-closest/)



### [18. 四数之和](https://leetcode.cn/problems/4sum/)



### [611. 有效三角形的个数](https://leetcode.cn/problems/valid-triangle-number/)

## 相向双指针 2

### [11. 盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/)

分析题目：高度取当前两条线最小的，宽度取两条线之间的距离。

分类讨论：当前已有的长方形面积，固定当前高的那条线，另一条短线移动

- 若是中间更短的线/一样长的线，即高度/宽度减小，不可能比原来面积大；
- 若是中间有更长的线，则高增大，宽减小，需判断和原面积的大小；

即**若要找到面积更大的，则不可能是和当前的短线组成的**。

```python
class Solution:
    def maxArea(self, height: List[int]) -> int:
        left = 0
        right = len(height) - 1
        ans = 0
        while left < right:
            area = min(height[left], height[right]) * (right - left)
            ans = max(ans, area)
            if height[left] > height[right]:	# 固定当前高的那条线
                right -= 1
            else:
                left += 1
        return ans
```

### [42. 接雨水](https://leetcode.cn/problems/trapping-rain-water/)

#### 前后缀分解/动态规划

计算每个单位的水桶可以接多少水，单位水桶左边的高度取决于左边的最大高度，右边取决于右边的最大高度；

则计算前缀最大值数组、后缀最大值数组，即保证当前单位水桶中的水是不会流出去的。

> 对于当前列，只需关注左边最高墙和右边最高墙中较矮的一个即可，三种情况：
> - 较矮墙高度大于当前列，则当前列的水量为 `矮墙高度-当前列高度`；
> - 较矮墙高度小于当前列，则当前列无水；
> - 较矮墙高度等于当前列，则当前列无水。
> 
> 最两端不用考虑，因为一定不会有水。
> 
> [windliang 思路分析及多解](https://leetcode.cn/problems/trapping-rain-water/solutions/9112/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-w-8/)

```python
class Solution:
    def trap(self, height: List[int]) -> int:
    	# 时间复杂度 O(n)
    	# 空间复杂度 O(n)
        n = len(height)
        
        # 第i列左侧最高墙
        pre_max = [0] * n
        pre_max[0] = height[0]
        for i in range(1, n):
            pre_max[i] = max(pre_max[i - 1], height[i])
            
        # 第i列右侧最高墙
        suf_max = [0] * n
        suf_max[n - 1] = height[n - 1]
        for i in range(n - 2, -1, -1):
            suf_max[i] = max(suf_max[i + 1], height[i])
            
        ans = 0
        for pre, suf, h in zip(pre_max, suf_max, height):
            ans += min(pre, suf) - h
            
        return ans
```

#### 相向双指针

若左侧最大值比右侧最大值小，则当前木桶接水的容量即为左侧最大值，随后向右扩展；反之，同理。

```python
class Solution:
    def trap(self, height: List[int]) -> int:
        # 时间复杂度 O(n)
        # 空间复杂度 O(1)
        n = len(height)
        ans = 0

        left = 0
        right = n - 1

        pre_max = 0
        suf_max = 0

        while left < right:
            pre_max = max(pre_max, height[left])
            suf_max = max(suf_max, height[right])
            if pre_max < suf_max:
                ans += pre_max - height[left]
                left += 1
            else:
                ans += suf_max - height[right]
                right -= 1
                
        return ans
```

#### 单调栈

```python

```

### [125. 验证回文串](https://leetcode.cn/problems/valid-palindrome/)



### [2105. 给植物浇水 II](https://leetcode.cn/problems/watering-plants-ii/)

## 滑动窗口

同向双指针

### [209. 长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/)

利用数组相加后得到的 s 的值的单调性，双指针实现。

```python
class Solution:
    def minSubArrayLen(self, target: int, nums: List[int]) -> int:
    	# 时间复杂度O(n)
    	# 空间复杂度O(1)
        n = len(nums)
        ans = float('inf')
        left = 0
        s = 0
        for right, x in enumerate(nums):  # 枚举右端点
            s += x
            # 由于均未正数，向右移动添加的值的总和只会更大，长度只会>=最小目标值长度
            while s >= target:
                ans = min(ans, right - left + 1)
                s -= nums[left]
                left += 1  # 满足条件，左端点右移
        return ans if ans != float('inf') else 0
```

> 虽然写了个二重循环，但是内层循环中对 left 加一的总执行次数不会超过 n 次，所以总的时间复杂度为 O(n)。

### [3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)

```python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        # 时间复杂度 O(n)
        # 空间复杂度 O(128) O(1) O(len(set(s)))

        # # 用字符串
        # sub = ""
        # ans = 0
        # left = 0
        # for right, c in enumerate(s):
        #     sub += c
        #     while sub.count(c) > 1:
        #         sub = sub[1:]
        #         left += 1
        #     ans = max(ans, right - left + 1)
        # return ans

        # # 用哈希表
        # ans = 0
        # left = 0
        # cnt = defaultdict(int)
        # for right, c in enumerate(s):
        #     cnt[c] += 1
        #     while cnt[c] > 1:
        #         cnt[s[left]] -= 1
        #         left += 1
        #     ans = max(ans, right - left + 1)
        # return ans

        # 哈希集合
        ans = 0
        left = 0
        window = set()
        for right, c in enumerate(s):
            while c in window:
                window.remove(s[left])
                left += 1
            window.add(c)
            ans = max(ans, right - left + 1)
        return ans
```

### [713. 乘积小于 K 的子数组](https://leetcode.cn/problems/subarray-product-less-than-k/)

若 left 到 right 之间的数总乘积都小于 k，则它们之间的任何数乘积都小于 k。

```python
class Solution:
    def numSubarrayProductLessThanK(self, nums: List[int], k: int) -> int:
        # 时间复杂度O(n)
        # 空间复杂度O(1)
        if k <= 1:
            return 0
        ans = 0
        left = 0
        s = 1
        for right, x in enumerate(nums):
            s *= x
            while s >= k:
                s /= nums[left]
                left += 1
            # 若 left 到 right 之间的数总乘积都小于 k，则它们之间的任何数乘积都小于 k。
            ans += right - left + 1
        return ans
```

### [76. 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)


## 二分查找

> 区间内的数（下标）都是还未确定与 target 的大小关系的，有的是 < target，有的是 ≥ target；区间外的数（下标）都是确定与 target 的大小关系的。

### [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)

```python
class Solution:
    def lower_bound1(self, nums, target):
        left = 0
        right = len(nums) - 1
        # 闭区间 [left, right]
        while left <= right:  # 区间不为空
            mid = left + (right - left) // 2
            if nums[mid] < target:
                left = mid + 1
            else:
                right = mid - 1
        # 循环结束后 left = right+1
        # 此时 nums[left-1] < target 而 nums[left] = nums[right+1] >= target
        # 所以 left 就是第一个 >= target 的元素下标
        return left

    def lower_bound2(self, nums, target):
        left = 0
        right = len(nums)
        # 左闭右开 [left, right)
        while left < right:  # 区间不为空
            mid = left + (right - left) // 2
            if nums[mid] < target:
                left = mid + 1
            else:
                right = mid
        # 循环结束后 left = right
        # 此时 nums[left-1] < target 而 nums[left] = nums[right] >= target
        # 所以 left 就是第一个 >= target 的元素下标
        return left

    def lower_bound3(self, nums, target):
        left = -1
        right = len(nums)
        # 开区间[left, right]
        while left + 1 < right: # 区间不为空
            mid = left + (right - left) // 2
            if nums[mid] < target:
                left = mid
            else:
                right = mid
        # 循环结束后 left+1 = right
        # 此时 nums[left] < target 而 nums[right] >= target
        # 所以 right 就是第一个 >= target 的元素下标
        return right

    def searchRange(self, nums: List[int], target: int) -> List[int]:
        start = self.lower_bound3(nums, target)
        if start == len(nums) or nums[start] != target:
            return [-1, -1]
        end = self.lower_bound3(nums, target + 1) - 1
        return [start, end]
```

库函数写法

```python
def searchRange(self, nums: List[int], target: int) -> List[int]:
    start = bisect_left(nums, target)
    if start == len(nums) or nums[start] != target:
        return [-1, -1]
    end = bisect_right(nums, target) - 1
    return [start, end]
```

### [2529. 正整数和负整数的最大计数](https://leetcode.cn/problems/maximum-count-of-positive-integer-and-negative-integer/)

### [2300. 咒语和药水的成功对数](https://leetcode.cn/problems/successful-pairs-of-spells-and-potions/)


### [1385. 两个数组间的距离值](https://leetcode.cn/problems/find-the-distance-value-between-two-arrays/)

### [2080. 区间内查询数字的频率](https://leetcode.cn/problems/range-frequency-queries/)

### [2563. 统计公平数对的数目](https://leetcode.cn/problems/count-the-number-of-fair-pairs/)

### [875. 爱吃香蕉的珂珂](https://leetcode.cn/problems/koko-eating-bananas/)

### [2187. 完成旅途的最少时间](https://leetcode.cn/problems/minimum-time-to-complete-trips/)

### [275. H 指数 II](https://leetcode.cn/problems/h-index-ii/)

### [2861. 最大合金数](https://leetcode.cn/problems/maximum-number-of-alloys/)

### [2439. 最小化数组中的最大值](https://leetcode.cn/problems/minimize-maximum-of-array/)

### [2517. 礼盒的最大甜蜜度](https://leetcode.cn/problems/maximum-tastiness-of-candy-basket/)

## 二分查找变形

分析题目，确定当前题目中的 **target** 所在的二分区间。

### [162. 寻找峰值](https://leetcode.cn/problems/find-peak-element/)

`nums[-1] = nums[n] = -∞` 即一定存在峰值，判断 `nums[i]` 和 `nums[i+1]` 大小，若 `>` 说明左边一定存在峰值；若 `<` 说明右边一定存在峰值。

```python
class Solution:
    def findPeakElement(self, nums: List[int]) -> int:
        left = 0
        right = len(nums) - 1
        while left < right:
            mid = left + (right - left) // 2
            if nums[mid] > nums[mid + 1]:
                right = mid
            else:
                left = mid + 1
        return left
```

### [153. 寻找旋转排序数组中的最小值](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/) @

> `x=nums[mid]` 判断 x 和数组最小值的位置关系，谁在左边，谁在右边？
> 
> 把 x 与最后一个数 `nums[n−1]` 比大小...

```python
class Solution:
    def findMin(self, nums: List[int]) -> int:
        left = 0
        right = len(nums) - 1
        while left < right:
            mid = left + (right - left) // 2
            if nums[mid] > nums[-1]:
                left = mid + 1
            else:
                right = mid
        return nums[left]
```

### [33. 搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/)

```python

```

### [74. 搜索二维矩阵](https://leetcode.cn/problems/search-a-2d-matrix/) @



### [1901. 寻找峰值 II](https://leetcode.cn/problems/find-a-peak-element-ii/)

### [154. 寻找旋转排序数组中的最小值 II](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii/)

