---
title: 灵神题单-基础算法精讲刷题记录
date: 2025-12-28
updated: 2025-12-28
tags:
  - 刷题记录
categories:
  - 程序设计
description: 灵神题单-基础算法精讲刷题记录
---
[【基础算法精讲·题目汇总】](https://github.com/EndlessCheng/codeforces-go/blob/master/leetcode/README.md) [【基础算法精讲】](https://space.bilibili.com/206214/channel/collectiondetail?sid=842776) 

## 相向双指针

### [167. 两数之和 II - 输入有序数组](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/)

利用数组有序这一特点，左右两个指针相加和 target 相比，则每次遍历所获得的信息量为 n；暴力做法每次遍历所获得的信息量为 1。

```python
class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        left = 0
        right = len(numbers) - 1
        while left < right:
            if numbers[left] + numbers[right] > target:
                right -= 1
            elif numbers[left] + numbers[right] < target:
                left += 1
            else:
                return [left + 1, right + 1]
        return []
```

### [15. 三数之和](https://leetcode.cn/problems/3sum/)

排序，枚举 i，即将问题转换为另外两个数之和的问题；

*不可包含重复的三元组*，先分析什么时候会出现重复的三元组（eg：`[-4, -1, -1, 0, 1, 2]`，前面两个 -1 和后面的数组合会重复）遇见重复跳过即可。

```python
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        nums.sort()
        ans = []
        n = len(nums)
        for i in range(n - 2):
            if i > 0 and nums[i] == nums[i - 1]:
                continue
                
            # 两种优化
            if nums[i] + nums[i + 1] + nums[i + 2] > 0:
                break
            if nums[i] + nums[-1] + nums[-2] < 0:
                continue
            
            j = i + 1
            k = n - 1
            while j < k:
                s = nums[i] + nums[j] + nums[k]
                if s > 0:
                    k -= 1
                elif s < 0:
                    j += 1
                else:
                    # ans.append([nums[i], nums[j], nums[k]])
                    # j += 1
                    # while j < k and nums[j] == nums[j - 1]:
                    #     j += 1
                    # k -= 1
                    # while j < k and nums[k] == nums[k + 1]:
                    #     k -= 1

                    # j == i + 1 表示刚开始双指针，j 左边没有数字
                    # nums[j] != nums[j - 1] 说明与上一轮的三元组不同
                    if j == i + 1 or nums[j] != nums[j - 1]:
                        ans.append([nums[i], nums[j], nums[k]])
                    j += 1
                    k -= 1
        return ans
```

### [2824. 统计和小于目标的下标对数目](https://leetcode.cn/problems/count-pairs-whose-sum-is-less-than-target/)



### [16. 最接近的三数之和](https://leetcode.cn/problems/3sum-closest/)



### [18. 四数之和](https://leetcode.cn/problems/4sum/)



### [611. 有效三角形的个数](https://leetcode.cn/problems/valid-triangle-number/)
