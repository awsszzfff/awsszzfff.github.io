---
title: Hot100
date: 2025-12-29
updated: 2025-12-29
tags:
  - 刷题记录
categories:
  - 程序设计
description: Hot100
---
## 哈希

### [1. 两数之和](https://leetcode.cn/problems/two-sum/)

`nums[i] + nums[j] = target` -> `nums[j] = target - nums[i]`

哈希表法，枚举右边。

> 枚举右，维护左/寻找左

![[attachments/20251229.png]]

```python
# 枚举 j （枚举右边，即左边信息已知了）
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        idx = dict()
        for j, x in enumerate(nums):
            if target - x in idx:   # 在左边找 nums[i]，满足 nums[i] + x = target
                return [idx[target - x], j]
            idx[x] = j
       
                 
# 枚举 i （需要多一步先遍历操作，因为并不知道右边的信息）
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        idx = {}
        for j, x in enumerate(nums):  # 先将所有的数及下标记录
            idx[x] = j  # 右边的覆盖左边
        for i, x in enumerate(nums):
            if idx[x] == i:  # 右边再没有 x 了，避免重复使用到当前数
                del idx[x]
            if target - x in idx:   # 在右边找 nums[j]，满足 x + nums[j] = target
                return [i, idx[target - x]]
```

### [49. 字母异位词分组](https://leetcode.cn/problems/group-anagrams/)

```python
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        d = defaultdict(list)
        for s in strs:
            sorted_s = ''.join(sorted(s))
            d[sorted_s].append(s)
        return list(d.values())
```

### [128. 最长连续序列](https://leetcode.cn/problems/longest-consecutive-sequence/)

```python
class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        st = set(nums)
        ans = 0
        for x in st:
            if x - 1 in st:  # 如果x不是序列的起点，则直接跳过
                continue
            y = x + 1
            while y in st:
                y += 1
            ans = max(ans, y - x)
            # 优化：若当前序列长已经>len(st)/2了，则不可能存在比他更大的序列长度了
            if ans * 2 >= len(st):
                break
        return ans
```

## 双指针

### [283. 移动零](https://leetcode.cn/problems/move-zeroes/description/)

```python

```

### [11. 盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/)

分析题目：高度取当前两条线最小的，宽度取两条线之间的距离。

分类讨论：当前已有的长方形面积，固定当前高的那条线，另一条短线移动

- 若是中间更短的线/一样长的线，即高度/宽度减小，不可能比原来面积大；
- 若是中间有更长的线，则高增大，宽减小，需判断和原面积的大小；

即**若要找到面积更大的，则不可能是和当前的短线组成的**。

```python
class Solution:
    def maxArea(self, height: List[int]) -> int:
        left = 0
        right = len(height) - 1
        ans = 0
        while left < right:
            area = min(height[left], height[right]) * (right - left)
            ans = max(ans, area)
            if height[left] > height[right]:	# 固定当前高的那条线
                right -= 1
            else:
                left += 1
        return ans
```

### [15. 三数之和](https://leetcode.cn/problems/3sum/)

排序，枚举 i，即将问题转换为另外两个数之和的问题；

*不可包含重复的三元组*，先分析什么时候会出现重复的三元组（eg：`[-4, -1, -1, 0, 1, 2]`，前面两个 -1 和后面的数组合会重复）遇见重复跳过即可。

```python
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        nums.sort()
        ans = []
        n = len(nums)
        for i in range(n - 2):
            if i > 0 and nums[i] == nums[i - 1]:
                continue
                
            # 两种优化
            if nums[i] + nums[i + 1] + nums[i + 2] > 0:
                break
            if nums[i] + nums[-1] + nums[-2] < 0:
                continue
            
            j = i + 1
            k = n - 1
            while j < k:
                s = nums[i] + nums[j] + nums[k]
                if s > 0:
                    k -= 1
                elif s < 0:
                    j += 1
                else:
                    # ans.append([nums[i], nums[j], nums[k]])
                    # j += 1
                    # while j < k and nums[j] == nums[j - 1]:
                    #     j += 1
                    # k -= 1
                    # while j < k and nums[k] == nums[k + 1]:
                    #     k -= 1

                    # j == i + 1 表示刚开始双指针，j 左边没有数字
                    # nums[j] != nums[j - 1] 说明与上一轮的三元组不同
                    if j == i + 1 or nums[j] != nums[j - 1]:
                        ans.append([nums[i], nums[j], nums[k]])
                    j += 1
                    k -= 1
        return ans
```

### [42. 接雨水](https://leetcode.cn/problems/trapping-rain-water/)

#### 前后缀分解/动态规划

计算每个单位的水桶可以接多少水，单位水桶左边的高度取决于左边的最大高度，右边取决于右边的最大高度；

则计算前缀最大值数组、后缀最大值数组，即保证当前单位水桶中的水是不会流出去的。

> 对于当前列，只需关注左边最高墙和右边最高墙中较矮的一个即可，三种情况：
> - 较矮墙高度大于当前列，则当前列的水量为 `矮墙高度-当前列高度`；
> - 较矮墙高度小于当前列，则当前列无水；
> - 较矮墙高度等于当前列，则当前列无水。
> 
> 最两端不用考虑，因为一定不会有水。
> 
> [windliang 思路分析及多解](https://leetcode.cn/problems/trapping-rain-water/solutions/9112/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-w-8/)

```python
class Solution:
    def trap(self, height: List[int]) -> int:
    	# 时间复杂度 O(n)
    	# 空间复杂度 O(n)
        n = len(height)
        
        # 第i列左侧最高墙
        pre_max = [0] * n
        pre_max[0] = height[0]
        for i in range(1, n):
            pre_max[i] = max(pre_max[i - 1], height[i])
            
        # 第i列右侧最高墙
        suf_max = [0] * n
        suf_max[n - 1] = height[n - 1]
        for i in range(n - 2, -1, -1):
            suf_max[i] = max(suf_max[i + 1], height[i])
            
        ans = 0
        for pre, suf, h in zip(pre_max, suf_max, height):
            ans += min(pre, suf) - h
            
        return ans
```

#### 相向双指针

若左侧最大值比右侧最大值小，则当前木桶接水的容量即为左侧最大值，随后向右扩展；反之，同理。

```python
class Solution:
    def trap(self, height: List[int]) -> int:
        # 时间复杂度 O(n)
        # 空间复杂度 O(1)
        n = len(height)
        ans = 0

        left = 0
        right = n - 1

        pre_max = 0
        suf_max = 0

        while left < right:
            pre_max = max(pre_max, height[left])
            suf_max = max(suf_max, height[right])
            if pre_max < suf_max:
                ans += pre_max - height[left]
                left += 1
            else:
                ans += suf_max - height[right]
                right -= 1
                
        return ans
```

#### 单调栈

```python

```

## 滑动窗口

### [3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)

```python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        # 时间复杂度 O(n)
        # 空间复杂度 O(128) O(1) O(len(set(s)))

        # # 用字符串
        # sub = ""
        # ans = 0
        # left = 0
        # for right, c in enumerate(s):
        #     sub += c
        #     while sub.count(c) > 1:
        #         sub = sub[1:]
        #         left += 1
        #     ans = max(ans, right - left + 1)
        # return ans

        # # 用哈希表
        # ans = 0
        # left = 0
        # cnt = defaultdict(int)
        # for right, c in enumerate(s):
        #     cnt[c] += 1
        #     while cnt[c] > 1:
        #         cnt[s[left]] -= 1
        #         left += 1
        #     ans = max(ans, right - left + 1)
        # return ans

        # 哈希集合
        ans = 0
        left = 0
        window = set()
        for right, c in enumerate(s):
            while c in window:
                window.remove(s[left])
                left += 1
            window.add(c)
            ans = max(ans, right - left + 1)
        return ans
```

找到字符串中所有字母异位词

## 子串

## 普通数组

## 矩阵

## 链表

### [206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/)

```python
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        cur = head
        pre = None
        while cur:
            nxt = cur.next
            cur.next = pre
            pre = cur
            cur = nxt
        return pre
```

### [25. K 个一组翻转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group/)

![[attachments/20260106-1.png]]

```python
class Solution:
    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:
        dummy = ListNode(next=head)

        cur = head
        count = 0
        while cur:
            count += 1
            cur = cur.next
        n = count // k

        p0 = dummy
        pre = None
        cur = p0.next
        for _ in range(n):
            for _ in range(k):
                nxt = cur.next
                cur.next = pre
                pre = cur
                cur = nxt
            nxt = p0.next
            p0.next.next = cur
            p0.next = pre
            p0 = nxt

        return dummy.next
```

## 二叉树

## 图论

## 回溯

## 二分查找

> 区间内的数（下标）都是还未确定与 target 的大小关系的，有的是 < target，有的是 ≥ target；区间外的数（下标）都是确定与 target 的大小关系的。

### [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)

```python
class Solution:
    def lower_bound1(self, nums, target):
        left = 0
        right = len(nums) - 1
        # 闭区间 [left, right]
        while left <= right:  # 区间不为空
            mid = left + (right - left) // 2
            if nums[mid] < target:
                left = mid + 1
            else:
                right = mid - 1
        # 循环结束后 left = right+1
        # 此时 nums[left-1] < target 而 nums[left] = nums[right+1] >= target
        # 所以 left 就是第一个 >= target 的元素下标
        return left

    def lower_bound2(self, nums, target):
        left = 0
        right = len(nums)
        # 左闭右开 [left, right)
        while left < right:  # 区间不为空
            mid = left + (right - left) // 2
            if nums[mid] < target:
                left = mid + 1
            else:
                right = mid
        # 循环结束后 left = right
        # 此时 nums[left-1] < target 而 nums[left] = nums[right] >= target
        # 所以 left 就是第一个 >= target 的元素下标
        return left

    def lower_bound3(self, nums, target):
        left = -1
        right = len(nums)
        # 开区间[left, right]
        while left + 1 < right: # 区间不为空
            mid = left + (right - left) // 2
            if nums[mid] < target:
                left = mid
            else:
                right = mid
        # 循环结束后 left+1 = right
        # 此时 nums[left] < target 而 nums[right] >= target
        # 所以 right 就是第一个 >= target 的元素下标
        return right

    def searchRange(self, nums: List[int], target: int) -> List[int]:
        start = self.lower_bound3(nums, target)
        if start == len(nums) or nums[start] != target:
            return [-1, -1]
        end = self.lower_bound3(nums, target + 1) - 1
        return [start, end]
```

库函数写法

```python
def searchRange(self, nums: List[int], target: int) -> List[int]:
    start = bisect_left(nums, target)
    if start == len(nums) or nums[start] != target:
        return [-1, -1]
    end = bisect_right(nums, target) - 1
    return [start, end]
```

### [33. 搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/)

#### 两次二分

先找最小值，再在有序数组中找 target

```python
class Solution:
    def findMin(self, nums):
        left = 0
        right = len(nums)
        while left < right:
            mid = left + (right - left) // 2
            if nums[mid] > nums[-1]:
                left = mid + 1
            else:
                right = mid
        return left

    def lower_bound(self, nums, left, right, target):
        while left < right:
            mid = left + (right - left) // 2
            if nums[mid] < target:
                left = mid + 1
            else:
                right = mid
        return left if nums[left] == target else -1

    def search(self, nums: List[int], target: int) -> int:
        i = self.findMin(nums)
        if target > nums[-1]:
            return self.lower_bound(nums, 0, i, target)
        return self.lower_bound(nums, i, len(nums), target)
```

#### 一次二分

> - 如果 x 和 target 在不同的递增段：
> 	- 如果 target 在第一段，x 在第二段，说明 target 在 x 在左边。
> 	- 如果 x 在第一段，target 在第二段，说明 target 在 x 在右边。
> - 如果 x 和 target 在相同的递增段：
> 	- 和 lowerBound 函数一样，比较 x 和 target 的大小即可。

```python
# 写法一
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        left = 0
        right = len(nums)
        while left < right:
            mid = left + (right - left) // 2
            x = nums[mid]
            if target > nums[-1] >= x:
                right = mid
            elif x > nums[-1] >= target:
                left = mid + 1
            elif x >= target:
                right = mid
            else:
                left = mid + 1
        return left if nums[left] == target else -1
```

> 只讨论 target 在 x 左边，或者 x=target 的情况。其余情况 target 一定在 x 的右边
> 
> - 如果 `x > nums[n−1]`，说明 x 在第一段中，那么 target 也必须在第一段中（否则 target 一定在 x 的右边）且 x 必须大于等于 target。
> 	- 写成代码就是 `target > nums[n - 1] && x >= target`。
> - 如果 `x <= nums[n−1]`，说明 x 在第二段中（或者 nums 只有一段），那么 target 可以在第一段，也可以在第二段。
> 	- 如果 target 在第一段，那么 target 一定在 x 左边。
> 	- 如果 target 在第二段，那么 x 必须大于等于 target。
> 	- 写成代码就是 `target > nums[n - 1] || x >= target`。

```python
# 写法二
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        def check(i):
            x = nums[i]
            if x > nums[-1]:
                return target > nums[-1] and x >= target
            return target > nums[-1] or x >= target

        left, right = 0, len(nums)
        while left < right:
            mid = left + (right - left) // 2
            if check(mid):
                right = mid
            else:
                left = mid + 1
        return left if nums[left] == target else -1
```

### [153. 寻找旋转排序数组中的最小值](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/)

> `x=nums[mid]` 判断 x 和数组最小值的位置关系，谁在左边，谁在右边？
> 
> 把 x 与最后一个数 `nums[n−1]` 比大小
> 
> - 如果 `x>nums[n−1]`，那么可以推出以下结论：
> 	- nums 一定被分成左右两个递增段；
> 	- 第一段的所有元素均大于第二段的所有元素；
> 	- x 在第一段。
> 	- 最小值在第二段。
> 	- 所以 x 一定在最小值的左边。
> - 如果 `x <= nums[n−1]`，那么 x 一定在第二段。（或者 nums 就是递增数组，此时只有一段。）
> 	- x 要么是最小值，要么在最小值右边。

> 对于二分来说，代码中的 `if (nums[mid] > nums[-1])` 在 `mid = n − 1` 的时候一定不成立。所以对于左闭右开的写法，right 可以选择从 `n - 1` 处开始

```python
class Solution:
    def findMin(self, nums: List[int]) -> int:
        left = 0
        right = len(nums) - 1
        while left < right:
            mid = left + (right - left) // 2
            if nums[mid] > nums[-1]:
                left = mid + 1
            else:
                right = mid
        return nums[left]
```

## 栈

## 堆

## 贪心算法

## 多维动态规划

## 技巧
